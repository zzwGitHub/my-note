# 第五章

## 5.1 类、超类和子类

### 5.1.1 ~ 5.1.7

- 在 Java 中，所有的继承都是公有继承
- 在 Manager extends Employee 中：
  - Employee 可以称为：超类( **superclass**)、 基类（ **base** **class**) 或父类（**parent** **class**)
  - Manager 可以称为：子类（**subclass**) 、派生类 ( **derived** **class**) 或孩子类（**child** **class**)
- 子类会从父类中继承得到 父类的 域 ，即便是私有的域也可以继承得到。但是在子类中无法直接访问，需要使用父类的公有 get 方法才能访问到，为了区分，可以使用 super 关键字：`super.getName()`
- 子类不会从父类继承得到 私有的 方法
- 子类构造器
  - 由于 Manager 类的构造器不能访问 Employee 类的私有域， 所以必须利用 Employee 类的构造器对这部分私有域进行初始化，我们可以通过 super 实现对超类构造器的调用。
  - 使用super 调用构造器的语句必须是子类构造器的**第一条语句**。（所以第一行用 this 了就没法用 super）
  - 如果子类的构造器没有显式地调用超类的构造器， 则将**自动地调用超类默认（没有参数 )的构造器**。 如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类的其他构造器，则 **Java 编译器将报告错误**。
- 一个对象变量可以指示多种实际类型的现象被称为多态（**polymorphism**)
- 由一个公共超类派生出来的所有类的集合被称为继承层次（ **inheritance hierarchy** )，在继承层次中， 从某个特定的类到其祖先的路径被称为该类的继承链 **(** **inheritance** **chain**)
- 方法的名字和参数列表称为方法的签名。返回值不是。
  - 因此，在覆盖方法时， 一定要保证返回类型的兼容性。 允许子类将覆盖方法的返回类型定义为原返回类型的子类型。
- 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是， 如果超类方法是 public, 子类方法一定要声明为 public。
- final 修饰符
  - 它修饰的域，构造对象之后就不允许改变它们的值了
  - 它修饰的类，不能被 extends（final 类中的所有方法自动的称为 final 方法，而不包括 域）
  - 它修饰的方法，不能被子类覆盖

### 5.1.8 强制类型转换

- 首先想明白一个问题：子类转成父类，是很自然的事情 `Father father = child` 就好了。
- 需要采取强制手段是 **父类 → 子类** 。也就是说，当我们知道这个 Employee 确实就是 Mananger 时，才可以强制类型转换了。
- 如果我们 Employee 不是 Mananger 时，会报错哦 ClassCastException 异常
  - 强制类型转换前使用 `instanceof` 校验一下，会很好
  - 只能在继承层次内进行类型转换
- `null instanceof C` 时，只是 false 而已，不会报错啦！
- 之所以这样处理是因为 null 没有引用任何对象， 当然也不会引用 C 类型的对象

### 5.1.9 抽象类

- 当在超类中想定义通用方法，而又不知如何实现时，使用 **abstract** 关键字修饰方法吧，那样就不用实现它了！
- 为了提高程序的清晰度， 包含一个或多个抽象方法的类本身 **也必须被声明为抽象的**
- 继承抽象类时，可以
  - 把所有抽象方法都实现了
  - 只实现部分抽象方法，那这个子类必须还得声明为抽象类
- 类即使不含有抽象方法，也可以将类声明为抽象类
- 抽象类不能被实例化
- 可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象

### 5.1.10 受保护访问

|           | 本类 | 本包中的其他类 | 子类 | 全部类 |
| :-------: | :--: | :------------: | :--: | :----: |
|  public   |  √   |       √        |  √   |   √    |
| protected |  √   |       √        |  √   |        |
|  (默认)   |  √   |       √        |      |        |
|  private  |  √   |                |      |        |

-  `B extends A` 中B的实例只能直接访问 B 类实例中 的Protected域，不能直接访问A中那个域

  解释：如果 类A 的某个 域 是默认的。那么在同包内的其他类，可操作这个 域（比如有个方法的入参是 类A 的实例，然后可以直接 通过点 拿到）。

  但是，如果B 跟 A 不在同一个包，那么B是通过 点 拿不到那个域的。

  如果 `B extends A` ，而恰巧 把 A的这个域设置成了 protected ，那么上述继承的情况 ，B就可以 通过 `this.` 拿到这个域了（如果是private可是点拿不到的哦~），注意这里拿到的是自己继承得到的 域

  **关键：** 在上述情况中，即便是 protected 了，B的实例也只能 直接访问 B 的域，而绝不能直接访问A的域（如果在同一个包里就行）

## 5.2 Object 对象

- 在 Java 中，只有基本类型 （ primitive types) 不是对象， 例如，数值、 字符和布尔类型的值都不是对象。

  所有的数组类型，不管是对象数组还是基本类型的数组都扩展了 Object 类。

- `Objects.equals(a,b)`挺好的方法，这方法两个都为null，也不会异常。只不过会为 true

  - 如果 a 和 b 都为 null， 返回 true ; 如果只有其中之一为 null， 则返回 false ; 否则返回a.equals(b)

- **Java** 语言规范要求 **equals** 方法具有下面的特性：

  - 自反性、对称性、传递性、一直性、x.equals(null) 要返回 false

- 一个优秀的 equals 实现建议，在书 169页

- 覆盖 equals 方法时，注意：它的入参是 Object 类型

- 使用 @Override 对覆盖超类的方法进行标记，这是为了避免发生 **以为自己覆盖，而没有** 的错误

- hashCode 方法应该与 equals 方法具有一致性

- Object 的 toString() 方法是 类名 + hashCode

- 只要对象通过 + 与字符串连接起来，就会默认调用 toString 方法

  - x.toString() 与 "" + x 效果是一样的
  - System.out.println(x) 也会调用 toString()

- 令人烦恼的是， 数组继承了 object 类的 toString 方法，数组类型将按照旧的格式打印。

- 强烈建议**为自定义的每一个类增加 toString 方法**。这样做不仅自己受益， 而且所有使用这个类的程序员也会从这个日志记录支持中受益匪浅。

## 5.3 泛型数组列表（其实就是ArrayList）

- ensureCapacity 方法 和 trimToSize 方法
- set方法，可以在add之后使用，可以起到替换的作用

## 5.4 对象包装器与自动装箱

- Integer 之类的，叫包装器（wrapper），它们是 final 的，不能定义他们的子类

- ArrayList<Integer>的效率远远低于 int[]

- 自动装箱

  - 首先明确，一个是类，一个是基本类型，有的时候需要用类，有的时候需要用基本类型

  - 在需要使用类的时候，比如 `arrayList.add(3)` 就相当于

    `arrayList.add(Integer.valueOf(3))`

  - 也就是“自动的”装箱了

- 自动拆箱

  - 在需要用基本类型的时候，比如 1 + n 就相当于`1 + n.intValue()`

- 最后强调一下，装箱和拆箱是 **编译器** 认可的，而 **不是虚拟机** 。编译器在生成类的字节码时， 插入必要的方法调用。虚拟机只是执行这些字节码。

## 5.5 参数数量可变的方法

- `Object…`参数类型与 `Object[ ]`完全一样
- The variable argument must be the last parameter，是可想而知的。

## 5.6 枚举类

- 枚举实际上就是类，他不能和类名、接口名重复哦~~

  其中的那些“单词”，就是一个个实例

- 枚举列出的若干固定 **大写单词** 实际上就是 **实例**

- 比较两个枚举是否相同时，永远不要用 `equals`，而直接使用 `==` 就可以了。

- 可以加入构造方法哦~

```
public enum Piano {
	YAMAHA(2500), CASIO(130), ROLAND(999);
    private double price;
		private Piano(double price) {
		this.price = price;
	}
	public double getPrice() {
		return this.price;
	}
}
```

- 所有的枚举类型都是 `Enum` 类的子类。它们继承了这个类的许多方法。其中最有用的一个是 `toString`， 这个方法能够返回枚举常量名。
- `toString` 的逆方法是静态方法 `valueOf` `Size s = Enum.valueOf(Size,class, "SMALL");` 可以将 s 设置成 `Size.SMALL`
- 每个枚举类型都有一个静态的 values 方法， 它将返回一个包含全部枚举值的数组 `Size[] values = Size.values() ;`
- ordinal 方 法 返 冋 enum 声 明 中 枚 举 常 量 的 位 置， 位 置 从 0 开始计数。

## 5.7 反射

- Class 类其实是泛型类

## 5.8 继承的设计技巧

1. 将公共操作和域放在超类
2. 不要使用 protected 域
   - 子类集合是无限制的，任何继承来的类，通过 点 的方式，直接就能操作 protected 域，破坏封装性
   - 在同一个包的其他类，都可以支持操作 protected 域，而不管是否是这个类的子类
3. 使用继承实现 is-a 关系
4. 除非所有继承的方法都有意义，否则不要使用继承
5. 覆盖方法是，不要改变预期的行为
6. 使用多态，而非类型信息

```java
if (x is of type1)
	action1(x);
else if (x is of type 2)
	action2(x);
```

这种情况时，如果两个action是相同的概念，就要考虑多态：在一个接口中定义 `action()` ，然后两个类都实现此接口，然后使用父类的变量（当然它可以引用了不同的类）直接`.action()`

7. 不要过多的使用反射